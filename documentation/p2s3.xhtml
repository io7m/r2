<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-r2 0.2.1 Documentation: 2.3. Coordinate Systems</title><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8"/><link rel="stylesheet" type="text/css" href="kstructural-layout.css"/><link rel="stylesheet" type="text/css" href="kstructural-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st300_body"><div class="st300_navbar st300_navbar_top"><table class="st300_navbar_table" summary="st300_Navigation bar"><tr><td class="st300_navbar_prev_title_cell">2.2. Concepts</td><td class="st300_navbar_up_title_cell">2. Design And Implementation</td><td class="st300_navbar_next_title_cell">2.4. Meshes</td></tr><tr><td class="st300_navbar_prev_file_cell"><a rel="previous" href="p2s2.xhtml#st300_p2s2" title="Go to previous page">Previous</a></td><td class="st300_navbar_up_file_cell"><a rel="up" href="p2.xhtml#st300_p2" title="Go to parent page">Up</a></td><td class="st300_navbar_next_file_cell"><a rel="next" href="p2s4.xhtml#st300_p2s4" title="Go to next page">Next</a></td></tr></table><hr class="st300_hr"/></div><div class="st300_section_container"><a id="di.coords"/><div class="st300_section_title_number"><a id="st300_p2s3" href="#st300_p2s3" title="Section 2.3: Coordinate Systems">2.3</a></div><div class="st300_section_title">Coordinate Systems</div><ul class="st300_contents st300_section_contents_outer st300_section_contents"><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss1" title="Link to subsection 2.3.1: Conventions">2.3.1. Conventions</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss2" title="Link to subsection 2.3.2: Object Space">2.3.2. Object Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss3" title="Link to subsection 2.3.3: World Space">2.3.3. World Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss4" title="Link to subsection 2.3.4: Eye Space">2.3.4. Eye Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss5" title="Link to subsection 2.3.5: Clip Space">2.3.5. Clip Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss6" title="Link to subsection 2.3.6: Normalized-Device Space">2.3.6. Normalized-Device Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s3.xhtml#st300_p2s3ss7" title="Link to subsection 2.3.7: Screen Space">2.3.7. Screen Space</a></li></ul><div class="st300_subsection_container"><a id="di.coords.conventions"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss1" href="#st300_p2s3ss1" title="Subsection 2.3.1: Conventions">2.3.1</a></div><div class="st300_subsection_title">Conventions</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c1" href="#st300_p2s3ss1c1" title="Paragraph 2.3.1.1">1</a></div><div class="st300_paragraph">This section attempts to describe the mathematical conventions that the <span class="st300_term package">r2</span> package uses with respect to coordinate systems. The <span class="st300_term package">r2</span> package generally does not deviate from standard OpenGL conventions, and this section does not attempt to give a rigorous formal definition of these existing conventions. It does however attempt to establish the naming conventions that the package uses to refer to the standard coordinate spaces <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4874_0" id="st300_fr_2739" title="Jump to footnote di.coords.whining (reference 0)">10</a>]</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c2" href="#st300_p2s3ss1c2" title="Paragraph 2.3.1.2">2</a></div><div class="st300_paragraph">The <span class="st300_term package">r2</span> package uses the <a class="st300_link_external" href="http://io7m.github.io/jtensors">jtensors</a> package for all mathematical operations on the CPU, and therefore shares its conventions with regards to coordinate system handedness. Important parts are repeated here, but the documentation for the <span class="st300_term package">jtensors</span> package should be inspected for details.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c3" href="#st300_p2s3ss1c3" title="Paragraph 2.3.1.3">3</a></div><div class="st300_paragraph">Any of the matrix functions that deal with rotations assume a right-handed coordinate system. This matches the system conventionally used by <a class="st300_link_external" href="http://opengl.org">OpenGL</a> (and most mathematics literature) . A right-handed coordinate system assumes that if the viewer is standing at the origin and looking towards negative infinity on the Z axis, then the X axis runs horizontally (left towards negative infinity and right towards positive infinity) , and the Y axis runs vertically (down towards negative infinity and up towards positive infinity). The following image demonstrates this axis configuration:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c4" href="#st300_p2s3ss1c4" title="Formal item 2.3.1.4: Right Handed Coordinate System">2.3.1.4 Right Handed Coordinate System</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="A right handed coordinate system diagram." src="images/axes2.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c5" href="#st300_p2s3ss1c5" title="Paragraph 2.3.1.5">5</a></div><div class="st300_paragraph">The <span class="st300_term package">jtensors</span> package adheres to the convention that a positive rotation around an axis represents a counter-clockwise rotation when viewing the system along the negative direction of the axis in question.</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c6" href="#st300_p2s3ss1c6" title="Formal item 2.3.1.6: Rotations">2.3.1.6 Rotations</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="A diagram of right-handed rotations." src="images/rotations.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c7" href="#st300_p2s3ss1c7" title="Paragraph 2.3.1.7">7</a></div><div class="st300_paragraph">The package uses the following matrices to define rotations around each axis:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c8" href="#st300_p2s3ss1c8" title="Formal item 2.3.1.8: Rotation of r radians around the X axis">2.3.1.8 Rotation of r radians around the X axis</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Rotation of r radians around the X axis." src="images/matrix_rx.png"/></div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c9" href="#st300_p2s3ss1c9" title="Formal item 2.3.1.9: Rotation of r radians around the Y axis">2.3.1.9 Rotation of r radians around the Y axis</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Rotation of r radians around the Y axis." src="images/matrix_ry.png"/></div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c10" href="#st300_p2s3ss1c10" title="Formal item 2.3.1.10: Rotation of r radians around the Z axis">2.3.1.10 Rotation of r radians around the Z axis</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Rotation of r radians around the Z axis." src="images/matrix_rz.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss1c11" href="#st300_p2s3ss1c11" title="Paragraph 2.3.1.11">11</a></div><div class="st300_paragraph">Which results in the following matrix for rotating <span class="st300_term expression">r</span> radians around the axis given by <span class="st300_term expression">(x, y, z)</span>, assuming <span class="st300_term expression">s = sin(r)</span> and <span class="st300_term expression">c = cos(r)</span>:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss1c12" href="#st300_p2s3ss1c12" title="Formal item 2.3.1.12: Rotation of r radians around an arbitrary axis">2.3.1.12 Rotation of r radians around an arbitrary axis</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Rotation of r radians around an arbitrary axis." src="images/rot_matrix.png"/></div></div></div><div class="st300_subsection_container"><a id="di.coords.object"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss2" href="#st300_p2s3ss2" title="Subsection 2.3.2: Object Space">2.3.2</a></div><div class="st300_subsection_title">Object Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss2c1" href="#st300_p2s3ss2c1" title="Paragraph 2.3.2.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Object space</span> is the local coordinate system used to describe the positions of vertices in meshes. For example, a unit cube with the origin placed at the center of the cube would have eight vertices with positions expressed as object-space coordinates:</div></div><div class="st300_formal_item"><a id="di.coords.object.cube"/><div class="st300_formal_item_title"><a id="st300_p2s3ss2c2" href="#st300_p2s3ss2c2" title="Formal item 2.3.2.2: Unit cube vertices">2.3.2.2 Unit cube vertices</a></div><div class="st300_formal_item_content"><pre class="st300_verbatim">cube = {
  (-0.5, -0.5, -0.5),
  ( 0.5, -0.5, -0.5),
  ( 0.5, -0.5,  0.5),
  (-0.5, -0.5,  0.5),

  (-0.5,  0.5, -0.5),
  ( 0.5,  0.5, -0.5),
  ( 0.5,  0.5,  0.5),
  (-0.5,  0.5,  0.5)
}</pre></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss2c3" href="#st300_p2s3ss2c3" title="Paragraph 2.3.2.3">3</a></div><div class="st300_paragraph">In other rendering systems, object space is sometimes referred to as <span class="st300_term term">local space</span>, or <span class="st300_term term">model space</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss2c4" href="#st300_p2s3ss2c4" title="Paragraph 2.3.2.4">4</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, object space is represented by the <a class="st300_link_external" href="apidocs/com/io7m/r2/spaces/R2SpaceObjectType.html">R2SpaceObjectType</a>.</div></div></div><div class="st300_subsection_container"><a id="di.coords.world"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss3" href="#st300_p2s3ss3" title="Subsection 2.3.3: World Space">2.3.3</a></div><div class="st300_subsection_title">World Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss3c1" href="#st300_p2s3ss3c1" title="Paragraph 2.3.3.1">1</a></div><div class="st300_paragraph">In order to position objects in a scene, they must be assigned a <a class="st300_link" href="p2s2.xhtml#di.concepts.transform">transform</a> that can be applied to each of their <a class="st300_link" href="p2s3.xhtml#di.coords.object">object space</a> vertices to yield absolute positions in so-called <span class="st300_term term">world space</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss3c2" href="#st300_p2s3ss3c2" title="Paragraph 2.3.3.2">2</a></div><div class="st300_paragraph">As an example, if the <a class="st300_link" href="p2s3.xhtml#di.coords.object.cube">unit cube</a> described above was assigned a transform that moved its origin to <span class="st300_term expression">(3, 5, 1)</span>, then its object space vertex <span class="st300_term expression">(-0.5, 0.5, 0.5)</span> would end up at <span class="st300_term expression">(3 + -0.5, 5 + 0.5, 1 + 0.5) = (2.5, 5.5, 1.5)</span> in world space.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss3c3" href="#st300_p2s3ss3c3" title="Paragraph 2.3.3.3">3</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, a transform applied to an object produces a 4x4 <span class="st300_term term">model matrix</span>. Multiplying the model matrix with the positions of the object space vertices yields vertices in world space.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss3c4" href="#st300_p2s3ss3c4" title="Paragraph 2.3.3.4">4</a></div><div class="st300_paragraph">Note that, despite the name, <span class="st300_term term">world space</span> does not imply that users have to store their actual world representation in this coordinate space. For example, flight simulators often have to transform their planet-scale world representation to an <span class="st300_term term">aircraft relative</span> representation for rendering to work around the issues inherent in rendering extremely large scenes. The basic issue is that the relatively low level of floating point precision available on current graphics hardware means that if the coordinates of objects within the flight simulator's world were to be used directly, the values would tend to be drastically larger than those that could be expressed by the available limited-precision floating point types on the GPU. Instead, simulators often transform the locations of objects in their worlds such that the aircraft is placed at the origin <span class="st300_term expression">(0, 0, 0)</span> and the objects are positioned relative to the aircraft before being passed to the GPU for rendering. As a concrete example, within the simulator's world, the aircraft may be at <span class="st300_term expression">(1882838.3, 450.0, 5892309.0)</span>, and a control tower nearby may be at <span class="st300_term expression">(1883838.5, 0.0, 5892809.0)</span>. These coordinate values would be far too large to pass to the GPU if a reasonable level of precision is required, but if the current aircraft location is subtracted from all positions, the coordinates in <span class="st300_term term">aircraft relative space</span> of the aircraft become <span class="st300_term expression">(0, 0, 0)</span> and the coordinates of the tower become <span class="st300_term expression">(1883838.5 - 1882838.3, 0.0 - 450.0, 5892809.0 - 5892309.0) = (1000.19, -450.0, 500.0)</span>. The <span class="st300_term term">aircraft relative space</span> coordinates are certainly small enough to be given to the GPU directly without risking imprecision issues, and therefore the simulator would essentially treat <span class="st300_term term">aircraft relative space</span> and <span class="st300_term package">r2</span> <span class="st300_term term">world space</span> as equivalent <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4904_0" id="st300_fr_3562" title="Jump to footnote di.coords.minecraft (reference 0)">11</a>]</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss3c5" href="#st300_p2s3ss3c5" title="Paragraph 2.3.3.5">5</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, world space is represented by the <a class="st300_link_external" href="apidocs/com/io7m/r2/spaces/R2SpaceWorldType.html">R2SpaceWorldType</a>.</div></div></div><div class="st300_subsection_container"><a id="di.coords.eye"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss4" href="#st300_p2s3ss4" title="Subsection 2.3.4: Eye Space">2.3.4</a></div><div class="st300_subsection_title">Eye Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c1" href="#st300_p2s3ss4c1" title="Paragraph 2.3.4.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Eye space</span> represents a coordinate system with the observer implicitly fixed at the origin <span class="st300_term expression">(0.0, 0.0, 0.0)</span> and looking towards infinity in the negative Z direction.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c2" href="#st300_p2s3ss4c2" title="Paragraph 2.3.4.2">2</a></div><div class="st300_paragraph">The main purpose of eye space is to simplify the mathematics required to implement various algorithms such as lighting. The problem with implementing these sorts of algorithms in <a class="st300_link" href="p2s3.xhtml#di.coords.world">world space</a> is that one must constantly take into account the position of the observer (typically by subtracting the location of the observer from each set of world space coordinates and accounting for any change in orientation of the observer). By fixing the orientation of the observer towards negative Z, and the position of the observer at <span class="st300_term expression">(0.0, 0.0, 0.0)</span>, and by transforming all vertices of all objects into the same system, the mathematics of lighting are greatly simplified. The majority of the rendering algorithms used in the <span class="st300_term package">r2</span> package are implemented in eye space.</div></div><div class="st300_paragraph_container"><a id="di.coords.eye.modelview"/><div class="st300_paragraph_number"><a id="st300_p2s3ss4c3" href="#st300_p2s3ss4c3" title="Paragraph 2.3.4.3">3</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, the observer produces a 4x4 <span class="st300_term term">view matrix</span>. Multiplying the view matrix with any given world space position yields a position in eye space. In practice, the view matrix <span class="st300_term expression">v</span> and the current object's model matrix <span class="st300_term expression">m</span> are concatenated (multiplied) to produce a <span class="st300_term term">model-view</span> matrix <span class="st300_term expression">mv = v * m</span> <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4081_0" id="st300_fr_3808" title="Jump to footnote di.coords.eye.anticommut (reference 0)">5</a>]</span>, and <span class="st300_term expression">mv</span> is then passed directly to the renderer's vertex shaders to transform the current object's vertices <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4090_0" id="st300_fr_3830" title="Jump to footnote di.coords.eye.efficient (reference 0)">6</a>]</span>.</div></div><div class="st300_paragraph_container"><a id="di.coords.eye.normal-matrix"/><div class="st300_paragraph_number"><a id="st300_p2s3ss4c4" href="#st300_p2s3ss4c4" title="Paragraph 2.3.4.4">4</a></div><div class="st300_paragraph">Additionally, as the <span class="st300_term package">r2</span> package does all lighting in eye space, it's necessary to transform the object space <span class="st300_term term">normal vectors</span> given in mesh data to eye space. However, the usual model-view matrix will almost certainly contain some sort of translational component and possibly a scaling component. Normal vectors are not supposed to be translated; they represent directions! A non-uniform scale applied to an object will also deform the normal vectors, making them non-perpendicular to the surface they're associated with:</div></div><div class="st300_formal_item"><a id="di.coords.eye.normals"/><div class="st300_formal_item_title"><a id="st300_p2s3ss4c5" href="#st300_p2s3ss4c5" title="Formal item 2.3.4.5: Unit cube vertices">2.3.4.5 Unit cube vertices</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Deformed normal vectors." src="images/normal_deform.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c6" href="#st300_p2s3ss4c6" title="Paragraph 2.3.4.6">6</a></div><div class="st300_paragraph">With the scaled triangle on the right, the normal vector is now not perpendicular to the surface (in addition to no longer being of unit length). The red vector indicates what the surface normal <span class="st300_term emphasis">should</span> be.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c7" href="#st300_p2s3ss4c7" title="Paragraph 2.3.4.7">7</a></div><div class="st300_paragraph">Therefore it's necessary to derive another 3x3 matrix known as the <span class="st300_term term">normal matrix</span> from the model-view matrix that contains just the rotational component of the original matrix. The full derivation of this matrix is given in <a class="st300_link_external" href="http://www.mathfor3dgameprogramming.com/">Mathematics for 3D Game Programming and Computer Graphics, Third Edition</a> <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4074_0" id="st300_fr_4027" title="Jump to footnote di.coords.eye.math3dgame (reference 0)">4</a>]</span>. Briefly, the normal matrix is equal to the inverse transpose of the top left 3x3 elements of an arbitrary 4x4 model-view matrix.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c8" href="#st300_p2s3ss4c8" title="Paragraph 2.3.4.8">8</a></div><div class="st300_paragraph">In other rendering systems, eye space is sometimes referred to as <span class="st300_term term">camera space</span>, or <span class="st300_term term">view space</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss4c9" href="#st300_p2s3ss4c9" title="Paragraph 2.3.4.9">9</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, eye space is represented by the <a class="st300_link_external" href="apidocs/com/io7m/r2/spaces/R2SpaceEyeType.html">R2SpaceEyeType</a>.</div></div></div><div class="st300_subsection_container"><a id="di.coords.clip"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss5" href="#st300_p2s3ss5" title="Subsection 2.3.5: Clip Space">2.3.5</a></div><div class="st300_subsection_title">Clip Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss5c1" href="#st300_p2s3ss5c1" title="Paragraph 2.3.5.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Clip space</span> is a homogeneous coordinate system in which OpenGL performs clipping of primitives (such as triangles). In OpenGL, clip space is effectively a left-handed coordinate system by default <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4502_0" id="st300_fr_4207" title="Jump to footnote di.coords.clip.invert (reference 0)">7</a>]</span>. Intuitively, coordinates in eye space are transformed with a <span class="st300_term term">projection</span> (normally either an <span class="st300_term term">orthographic</span> or <span class="st300_term term">perspective</span> projection) such that all vertices are projected into a homogeneous unit cube placed at the origin - <span class="st300_term term">clip space</span>  - resulting in four-dimensional <span class="st300_term expression">(x, y, z, w)</span> positions. Positions that end up outside of the cube are clipped (discarded) by dedicated clipping hardware, usually producing more triangles as a result.</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss5c2" href="#st300_p2s3ss5c2" title="Formal item 2.3.5.2: Primitive Clipping">2.3.5.2 Primitive Clipping</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="A diagram of primitive clipping." src="images/clipping.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss5c3" href="#st300_p2s3ss5c3" title="Paragraph 2.3.5.3">3</a></div><div class="st300_paragraph">A <span class="st300_term term">projection</span> effectively determines how objects in the three-dimensional scene are projected onto the two-dimensional <span class="st300_term term">viewing plane</span> (a computer screen, in most cases) . A <span class="st300_term term">perspective</span> projection transforms vertices such that objects that are further away from the viewing plane appear to be smaller than objects that are close to it, while an <span class="st300_term term">orthographic</span> projection preserves the perceived sizes of objects regardless of their distance from the viewing plane.</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss5c4" href="#st300_p2s3ss5c4" title="Formal item 2.3.5.4: Perspective projection">2.3.5.4 Perspective projection</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="A diagram of perspective projection." src="images/proj_perspective.png"/></div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss5c5" href="#st300_p2s3ss5c5" title="Formal item 2.3.5.5: Orthographic projection">2.3.5.5 Orthographic projection</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="A diagram of orthographic projection." src="images/proj_ortho.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss5c6" href="#st300_p2s3ss5c6" title="Paragraph 2.3.5.6">6</a></div><div class="st300_paragraph">Because <a class="st300_link" href="p2s3.xhtml#di.coords.eye">eye space</a> is a right-handed coordinate system by convention, but by default clip space is left-handed, the projection matrix used will invert the sign of the <span class="st300_term expression">z</span> component of any given point.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss5c7" href="#st300_p2s3ss5c7" title="Paragraph 2.3.5.7">7</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, the observer produces a 4x4 <span class="st300_term term">projection matrix</span>. The projection matrix is passed, along with the <a class="st300_link" href="p2s3.xhtml#di.coords.eye.modelview">model-view</a> matrix, to the renderer's vertex shaders. As is normal in OpenGL, the vertex shader produces clip space coordinates which are then used by the hardware rasterizer to produce color fragments onscreen.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss5c8" href="#st300_p2s3ss5c8" title="Paragraph 2.3.5.8">8</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, clip space is represented by the <a class="st300_link_external" href="apidocs/com/io7m/r2/spaces/R2SpaceClipType.html">R2SpaceClipType</a>.</div></div></div><div class="st300_subsection_container"><a id="di.coords.ndevice"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss6" href="#st300_p2s3ss6" title="Subsection 2.3.6: Normalized-Device Space">2.3.6</a></div><div class="st300_subsection_title">Normalized-Device Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss6c1" href="#st300_p2s3ss6c1" title="Paragraph 2.3.6.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Normalized-device space</span> is, by default, a left-handed <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4678_0" id="st300_fr_4568" title="Jump to footnote di.coords.ndevice.left (reference 0)">8</a>]</span> coordinate space in which <a class="st300_link" href="p2s3.xhtml#di.coords.clip">clip space</a> coordinates have been divided by their own <span class="st300_term expression">w</span> component (discarding the resulting <span class="st300_term expression">w = 1</span> component in the process), yielding three dimensional coordinates. The range of values in the resulting coordinates are effectively normalized by the division to fall within the ranges <span class="st300_term expression">[(-1, -1, -1), (1, 1, 1)]</span> <span class="st300_footnote_reference">[<a href="p2s3.xhtml#st300_f_4699_0" id="st300_fr_4628" title="Jump to footnote di.coords.ndevice.division (reference 0)">9</a>]</span>. The coordinate space represents a simplifying intermediate step between having clip space coordinates and getting something projected into a two-dimensional image <a class="st300_link" href="p2s3.xhtml#di.coords.screen">(screen space)</a> for viewing.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss6c2" href="#st300_p2s3ss6c2" title="Paragraph 2.3.6.2">2</a></div><div class="st300_paragraph">The <span class="st300_term package">r2</span> package does not directly use or manipulate values in normalized-device space; it is mentioned here for completeness.</div></div></div><div class="st300_subsection_container"><a id="di.coords.screen"/><div class="st300_subsection_title_number"><a id="st300_p2s3ss7" href="#st300_p2s3ss7" title="Subsection 2.3.7: Screen Space">2.3.7</a></div><div class="st300_subsection_title">Screen Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss7c1" href="#st300_p2s3ss7c1" title="Paragraph 2.3.7.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Screen space</span> is, by default, a left-handed coordinate system representing the screen (or window) that is displaying the actual results of rendering. If the screen is of width <span class="st300_term expression">w</span> and height <span class="st300_term expression">h</span>, and the current <span class="st300_term term">depth range</span> of the window is <span class="st300_term expression">[n, f]</span>, then the range of values in screen space coordinates runs from <span class="st300_term expression">[(0, 0, n), (w, h, f)]</span>. The origin <span class="st300_term expression">(0, 0, 0)</span> is assumed to be at the bottom-left corner.</div></div><div class="st300_paragraph_container"><a id="di.coords.screen.depth"/><div class="st300_paragraph_number"><a id="st300_p2s3ss7c2" href="#st300_p2s3ss7c2" title="Paragraph 2.3.7.2">2</a></div><div class="st300_paragraph">The depth range is actually a configurable value, but the <span class="st300_term package">r2</span> package keeps the OpenGL default. From the <span class="st300_term function">glDepthRange</span> function manual page:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s3ss7c3" href="#st300_p2s3ss7c3" title="Formal item 2.3.7.3: glDepthRange">2.3.7.3 glDepthRange</a></div><div class="st300_formal_item_content"><pre class="st300_verbatim">
After clipping and division by w, depth coordinates range from -1 to 1,
corresponding to the near and far clipping planes. glDepthRange specifies a
linear mapping of the normalized depth coordinates in this range to window
depth coordinates. Regardless of the actual depth buffer implementation,
window coordinate depth values are treated as though they range from 0
through 1 (like color components). Thus, the values accepted by
glDepthRange are both clamped to this range before they are accepted.
The setting of (0,1) maps the near plane to 0 and the far plane to 1.
With this mapping, the depth buffer range is fully utilized.</pre></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s3ss7c4" href="#st300_p2s3ss7c4" title="Paragraph 2.3.7.4">4</a></div><div class="st300_paragraph">As OpenGL, by default, specifies a depth range of <span class="st300_term expression">[0, 1]</span>, the positive Z axis points away from the observer and so the coordinate system is left handed.</div></div></div><div class="st300_footnotes"><hr/><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4074_0" href="p2s3.xhtml#st300_fr_4027" title="Jump back to reference 0 of footnote di.coords.eye.math3dgame">4</a>]</div><div class="st300_footnote_body">See section 4.5, Transforming normal vectors .</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4081_0" href="p2s3.xhtml#st300_fr_3808" title="Jump back to reference 0 of footnote di.coords.eye.anticommut">5</a>]</div><div class="st300_footnote_body">Note that matrix multiplication is not commutative.</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4090_0" href="p2s3.xhtml#st300_fr_3830" title="Jump back to reference 0 of footnote di.coords.eye.efficient">6</a>]</div><div class="st300_footnote_body">The reason for producing the concatenated matrix on the CPU and then passing it to the shader is efficiency; if a mesh had 1000 vertices, and the shader was passed m and v separately, the shader would repeatedly perform the same <span class="st300_term expression">mv = v * m</span> multiplication to produce mv for each vertex - yielding the exact same <span class="st300_term expression">mv</span> each time!</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4502_0" href="p2s3.xhtml#st300_fr_4207" title="Jump back to reference 0 of footnote di.coords.clip.invert">7</a>]</div><div class="st300_footnote_body">Because normalized device space is a left-handed system by default, with the viewer looking towards positive Z, and because the transformation from clip space to normalized device space for a given point is the division of the components of that point by the point's own <span class="st300_term expression">w</span> component.</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4678_0" href="p2s3.xhtml#st300_fr_4568" title="Jump back to reference 0 of footnote di.coords.ndevice.left">8</a>]</div><div class="st300_footnote_body">The handedness of the coordinate space is dependent on the <a class="st300_link" href="p2s3.xhtml#di.coords.screen.depth">depth range</a> configured for screen space.</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4699_0" href="p2s3.xhtml#st300_fr_4628" title="Jump back to reference 0 of footnote di.coords.ndevice.division">9</a>]</div><div class="st300_footnote_body">It is actually the division by <span class="st300_term expression">w</span> that produces the scaling effect necessary to produce the illusion of perspective in perspective projections.</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4874_0" href="p2s3.xhtml#st300_fr_2739" title="Jump back to reference 0 of footnote di.coords.whining">10</a>]</div><div class="st300_footnote_body">Almost all rendering systems use different names to refer to the same concepts, without ever bothering to document their conventions. This harms comprehension and generally wastes everybody's time.</div></div><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_4904_0" href="p2s3.xhtml#st300_fr_3562" title="Jump back to reference 0 of footnote di.coords.minecraft">11</a>]</div><div class="st300_footnote_body">A classic example of a modern game title that failed to anticipate precision issues is <a class="st300_link_external" href="http://minecraft.gamepedia.com/Far_Lands">Minecraft</a>.</div></div></div></div><div class="st300_navbar st300_navbar_bottom"><hr class="st300_hr"/><table class="st300_navbar_table" summary="st300_Navigation bar"><tr><td class="st300_navbar_prev_file_cell"><a rel="previous" href="p2s2.xhtml#st300_p2s2" title="Go to previous page">Previous</a></td><td class="st300_navbar_up_file_cell"><a rel="up" href="p2.xhtml#st300_p2" title="Go to parent page">Up</a></td><td class="st300_navbar_next_file_cell"><a rel="next" href="p2s4.xhtml#st300_p2s4" title="Go to next page">Next</a></td></tr><tr><td class="st300_navbar_prev_title_cell">2.2. Concepts</td><td class="st300_navbar_up_title_cell">2. Design And Implementation</td><td class="st300_navbar_next_title_cell">2.4. Meshes</td></tr></table></div></div></body></html>
