<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>com.io7m.r2 0.3.0-SNAPSHOT Documentation: 2.23. Normal Mapping</title><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8"/><link rel="stylesheet" type="text/css" href="kstructural-layout.css"/><link rel="stylesheet" type="text/css" href="kstructural-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st300_body"><div class="st300_navbar st300_navbar_top"><table class="st300_navbar_table" summary="st300_Navigation bar"><tr><td class="st300_navbar_prev_title_cell">2.22. Forward rendering (Translucency)</td><td class="st300_navbar_up_title_cell">2. Design And Implementation</td><td class="st300_navbar_next_title_cell">2.24. Logarithmic Depth</td></tr><tr><td class="st300_navbar_prev_file_cell"><a rel="previous" href="p2s22.xhtml#st300_p2s22" title="Go to previous page">Previous</a></td><td class="st300_navbar_up_file_cell"><a rel="up" href="p2.xhtml#st300_p2" title="Go to parent page">Up</a></td><td class="st300_navbar_next_file_cell"><a rel="next" href="p2s24.xhtml#st300_p2s24" title="Go to next page">Next</a></td></tr></table><hr class="st300_hr"/></div><div class="st300_section_container"><a id="di.normal-mapping"/><div class="st300_section_title_number"><a id="st300_p2s23" href="#st300_p2s23" title="Section 2.23: Normal Mapping">2.23</a></div><div class="st300_section_title">Normal Mapping</div><ul class="st300_contents st300_section_contents_outer st300_section_contents"><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s23.xhtml#st300_p2s23ss1" title="Link to subsection 2.23.1: Overview">2.23.1. Overview</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s23.xhtml#st300_p2s23ss2" title="Link to subsection 2.23.2: Tangent Space">2.23.2. Tangent Space</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s23.xhtml#st300_p2s23ss3" title="Link to subsection 2.23.3: Tangent/Bitangent Generation">2.23.3. Tangent/Bitangent Generation</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s23.xhtml#st300_p2s23ss4" title="Link to subsection 2.23.4: Normal Maps">2.23.4. Normal Maps</a></li><li class="st300_contents_item st300_contents_item1 st300_contents_item_subsection"><a href="p2s23.xhtml#st300_p2s23ss5" title="Link to subsection 2.23.5: Rendering With Normal Maps">2.23.5. Rendering With Normal Maps</a></li></ul><div class="st300_subsection_container"><a id="di.normal-mapping.overview"/><div class="st300_subsection_title_number"><a id="st300_p2s23ss1" href="#st300_p2s23ss1" title="Subsection 2.23.1: Overview">2.23.1</a></div><div class="st300_subsection_title">Overview</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss1c1" href="#st300_p2s23ss1c1" title="Paragraph 2.23.1.1">1</a></div><div class="st300_paragraph">The <span class="st300_term package">r2</span> package supports the use of <span class="st300_term term">tangent-space normal mapping</span> to allow for per-pixel control over the surface normal of rendered triangles. This allows for meshes to appear to have very complex surface details without requiring those details to actually be rendered as triangles within the scene.</div></div></div><div class="st300_subsection_container"><a id="di.normal-mapping.tangent-space"/><div class="st300_subsection_title_number"><a id="st300_p2s23ss2" href="#st300_p2s23ss2" title="Subsection 2.23.2: Tangent Space">2.23.2</a></div><div class="st300_subsection_title">Tangent Space</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss2c1" href="#st300_p2s23ss2c1" title="Paragraph 2.23.2.1">1</a></div><div class="st300_paragraph">Conceptually, there is a three-dimensional coordinate system based at each vertex, formed by three orthonormal basis vectors: The vertex <span class="st300_term term">normal</span>, <span class="st300_term term">tangent</span> and <span class="st300_term term">bitangent</span> vectors. The <span class="st300_term term">normal</span> vector is a the vector perpendicular to the surface at that vertex. The <span class="st300_term term">tangent</span> and <span class="st300_term term">bitangent</span> vectors are parallel to the surface, and each vector is obviously perpendicular to the other two vectors. This coordinate space is often referred to as <span class="st300_term term">tangent space</span>. The <span class="st300_term term">normal</span> vector actually forms the <span class="st300_term constant">Z</span> axis of the coordinate space, and this fact is central to the process of normal mapping. The coordinate system at each vertex may be left or right-handed depending on the arrangement of UV coordinates at that vertex.</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss2c2" href="#st300_p2s23ss2c2" title="Formal item 2.23.2.2: Vertex coordinate system">2.23.2.2 Vertex coordinate system</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Vertex coordinate system" src="images/normal.png"/></div></div></div><div class="st300_subsection_container"><a id="di.normal-mapping.tangent-bitangent-generation"/><div class="st300_subsection_title_number"><a id="st300_p2s23ss3" href="#st300_p2s23ss3" title="Subsection 2.23.3: Tangent/Bitangent Generation">2.23.3</a></div><div class="st300_subsection_title">Tangent/Bitangent Generation</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c1" href="#st300_p2s23ss3c1" title="Paragraph 2.23.3.1">1</a></div><div class="st300_paragraph"><span class="st300_term term">Tangent</span> and <span class="st300_term term">bitangent</span> vectors can be generated by the modelling programs that artists use to create polygon meshes, but, additionally, the <a class="st300_link_external" href="apidocs/com/io7m/r2/meshes/R2MeshTangents.html">R2MeshTangents</a> class can take an arbitrary mesh with only normal vectors and UV coordinates and produce tangent and bitangent vectors. The full description of the algorithm used is given in <a class="st300_link_external" href="http://www.mathfor3dgameprogramming.com/">Mathematics for 3D Game Programming and Computer Graphics, Third Edition</a> <span class="st300_footnote_reference">[<a href="p2s23.xhtml#st300_f_18450_0" id="st300_fr_17906" title="Jump to footnote di.normal-mapping.tangent-book (reference 0)">24</a>]</span>, and also in an <a class="st300_link_external" href="http://www.terathon.com/code/tangent.html">article</a> by the same author. The actual aim of tangent/bitangent generation is to produce a pair of orthogonal vectors that are oriented to the <span class="st300_term variable">x</span> and <span class="st300_term variable">y</span> axes of an arbitrary texture. In order to do achieve this, the generated vectors are oriented according to the UV coordinates in the mesh.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c2" href="#st300_p2s23ss3c2" title="Paragraph 2.23.3.2">2</a></div><div class="st300_paragraph">In the <span class="st300_term package">r2</span> package, the bitangent vector is not actually stored in the mesh data, and the tangent vector for any given vertex is instead stored as a four-component vector. The reasons for this are as follows: Because the normal, tangent, and bitangent vectors are known to be orthonormal, it should be possible to reconstruct any one of the three vectors given the other two at run-time. This would eliminate the need to store one of the vectors and would reduce the size of mesh data (including the on-disk size, and the size of mesh data allocated on the GPU) by a significant amount. Given any two orthogonal vectors <span class="st300_term constant">V0</span> and <span class="st300_term constant">V1</span>, a vector orthogonal to both can be calculated by taking the <span class="st300_term term">cross product</span> of both, denoted <span class="st300_term expression">(cross V0 V1)</span>. The problem here is that if <span class="st300_term constant">V0</span> is assumed to be the original normal vector <span class="st300_term constant">N</span>, and <span class="st300_term constant">V1</span> is assumed to be the original tangent vector <span class="st300_term constant">T</span>, there is no guarantee that <span class="st300_term expression">(cross N T)</span> will produce a vector equal to the original bitangent vector <span class="st300_term constant">B</span>: There are two possible choices of value for <span class="st300_term constant">B</span> that differ only in the sign of their coordinate values.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c3" href="#st300_p2s23ss3c3" title="Paragraph 2.23.3.3">3</a></div><div class="st300_paragraph">As an example, a triangle that will produce <span class="st300_term constant">T</span> and <span class="st300_term constant">B</span> vectors that form a right-handed coordinate system with the normal vector <span class="st300_term constant">N</span> (with UV coordinates indicated at each vertex):</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss3c4" href="#st300_p2s23ss3c4" title="Formal item 2.23.3.4: Tangent generation (RHC)">2.23.3.4 Tangent generation (RHC)</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Tangent generation (Resulting in a right-handed coordinate system)" src="images/tangent_gen_RHC.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c5" href="#st300_p2s23ss3c5" title="Paragraph 2.23.3.5">5</a></div><div class="st300_paragraph">The same triangle will produce vectors that form a left-handed system when generating vectors for another vertex (note that the result of <span class="st300_term expression">(Vector3f.cross N T) = (Vector3f.negation B)</span> ):</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss3c6" href="#st300_p2s23ss3c6" title="Formal item 2.23.3.6: Tangent generation (LHC)">2.23.3.6 Tangent generation (LHC)</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Tangent generation (Resulting in a left-handed coordinate system)" src="images/tangent_gen_LHC.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c7" href="#st300_p2s23ss3c7" title="Paragraph 2.23.3.7">7</a></div><div class="st300_paragraph">However, if the original tangent vector <span class="st300_term constant">T</span> was augmented with a piece of extra information that indicated whether or not the result of <span class="st300_term expression">(cross N T)</span> needed to be inverted, then reconstructing <span class="st300_term constant">B</span> would be trivial. Therefore, the fourth component of the tangent vector <span class="st300_term constant">T</span> contains <span class="st300_term constant">1.0</span> if <span class="st300_term expression">(cross N T) = B</span>, and <span class="st300_term constant">-1.0</span> if <span class="st300_term expression">(cross N T) = -B</span>. The bitangent vector can therefore be reconstructed by calculating <span class="st300_term expression">cross (N, T.xyz) * T.w</span>.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c8" href="#st300_p2s23ss3c8" title="Paragraph 2.23.3.8">8</a></div><div class="st300_paragraph">With the three vectors <span class="st300_term expression">(T, B, N)</span>, it's now possible construct a <span class="st300_term expression">3x3</span> matrix that can transform arbitrary vectors in <a class="st300_link" href="p2s23.xhtml#di.normal-mapping.tangent-space">tangent space</a> to <a class="st300_link" href="p2s3.xhtml#di.coords.object">object space</a>:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss3c9" href="#st300_p2s23ss3c9" title="Formal item 2.23.3.9: Tangent → Object matrix">2.23.3.9 Tangent → Object matrix</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Tangent → Object matrix" src="images/tangent_object_matrix.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss3c10" href="#st300_p2s23ss3c10" title="Paragraph 2.23.3.10">10</a></div><div class="st300_paragraph">With this matrix, it's now obviously possible to take an arbitrary vector in tangent space and transform it to object space. Then, with the current <span class="st300_term term">normal matrix</span> (object → eye), transform the object space vector all the way to <a class="st300_link" href="p2s3.xhtml#di.coords.eye">eye space</a> in the same manner as ordinary per-vertex object space normal vectors.</div></div></div><div class="st300_subsection_container"><a id="di.normal-mapping.map"/><div class="st300_subsection_title_number"><a id="st300_p2s23ss4" href="#st300_p2s23ss4" title="Subsection 2.23.4: Normal Maps">2.23.4</a></div><div class="st300_subsection_title">Normal Maps</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss4c1" href="#st300_p2s23ss4c1" title="Paragraph 2.23.4.1">1</a></div><div class="st300_paragraph">A <span class="st300_term term">normal map</span> is an ordinary RGB texture where each texel represents a tangent space normal vector. The <span class="st300_term variable">x</span> coordinate is stored in the red channel, the <span class="st300_term variable">y</span> coordinate is stored in the green channel, and the <span class="st300_term variable">z</span> coordinate is stored in the blue channel. The original coordinate values are assumed to fall within the inclusive range <span class="st300_term expression">[-1.0, 1.0]</span>, and these values are mapped to the range <span class="st300_term expression">[0.0, 1.0]</span> before being encoded to a specific pixel format.</div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss4c2" href="#st300_p2s23ss4c2" title="Paragraph 2.23.4.2">2</a></div><div class="st300_paragraph">As an example, the vector <span class="st300_term constant">(0.0, 0.0, 1.0)</span> is first mapped to <span class="st300_term constant">(0.5, 0.5, 1.0)</span> and then, assuming an image format with 8-bits of precision per color channel, encoded to <span class="st300_term constant">(0x7f, 0x7f, 0xff)</span>. This results in a pale blue color that is characteristic of tangent space normal maps:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss4c3" href="#st300_p2s23ss4c3" title="Formal item 2.23.4.3: (0.0, 0.0, 1.0)">2.23.4.3 (0.0, 0.0, 1.0)</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="(0.0, 0.0, 1.0)" src="images/normalmap_zerozeroone.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss4c4" href="#st300_p2s23ss4c4" title="Paragraph 2.23.4.4">4</a></div><div class="st300_paragraph">Typically, tangent space normal maps are generated from a simple height maps: Greyscale images where <span class="st300_term constant">0.0</span> denotes the lowest possible height, and <span class="st300_term constant">1.0</span> indicates the highest possible height. There are multiple algorithms that are capable of generating normal vectors from height maps, but the majority of them work from the same basic principle: For a given pixel with value <span class="st300_term variable">h</span> at location <span class="st300_term expression">(x, y)</span> in an image, the neighbouring pixel values at <span class="st300_term expression">(x - 1, y)</span>, <span class="st300_term expression">(x - 1, y - 1)</span>, <span class="st300_term expression">(x + 1, y)</span>, <span class="st300_term expression">(x + 1, y + 1)</span> are compared with <span class="st300_term variable">h</span> in order to determine the <span class="st300_term term">slope</span> between the height values. As an example, the <a class="st300_link_external" href="https://en.wikipedia.org/wiki/Prewitt_operator">Prewitt (3x3) operator</a> when used from the <a class="st300_link_external" href="https://code.google.com/p/gimp-normalmap/">gimp-normalmap</a> plugin will produce the following map from a given greyscale height map:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss4c5" href="#st300_p2s23ss4c5" title="Formal item 2.23.4.5: Prewitt 3x3 normal map">2.23.4.5 Prewitt 3x3 normal map</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Prewitt 3x3 normal map" src="images/normalmap_fromheight.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss4c6" href="#st300_p2s23ss4c6" title="Paragraph 2.23.4.6">6</a></div><div class="st300_paragraph">It is reasonably easy to infer the general directions of vectors from a visual inspection of a tangent space normal map alone. In the above image, the flat faces of the bricks are mostly pale blue. This is because the tangent space normal for that surface is pointing straight towards the viewer - mostly towards the positive <span class="st300_term variable">z</span> direction. The right edges of the bricks in the image are tinted with a pinkish hue - this indicates that the normal vectors at that pixel point mostly towards the positive <span class="st300_term variable">x</span> direction.</div></div></div><div class="st300_subsection_container"><a id="di.normal-mapping.rendering"/><div class="st300_subsection_title_number"><a id="st300_p2s23ss5" href="#st300_p2s23ss5" title="Subsection 2.23.5: Rendering With Normal Maps">2.23.5</a></div><div class="st300_subsection_title">Rendering With Normal Maps</div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss5c1" href="#st300_p2s23ss5c1" title="Paragraph 2.23.5.1">1</a></div><div class="st300_paragraph">As stated, the purpose of a normal map is to give per-pixel control over the surface normal for a given triangle during rendering. The process is as follows:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss5c2" href="#st300_p2s23ss5c2" title="Formal item 2.23.5.2: Rendering process">2.23.5.2 Rendering process</a></div><div class="st300_formal_item_content"><ol class="st300_list_ordered"><li class="st300_list_item">Calculate the bitangent vector <span class="st300_term constant">B</span> from the <span class="st300_term constant">N</span> and <span class="st300_term constant">T</span> vectors. This step is performed on a per-vertex basis (in the <span class="st300_term term">vertex shader</span> ).</li><li class="st300_list_item">Construct a <span class="st300_term constant">3x3</span> tangent → object matrix <span class="st300_term variable">M</span> from the <span class="st300_term expression">(T, B, N)</span> vectors. This step is performed on a per-fragment basis (in the <span class="st300_term term">fragment shader</span>) using the interpolated vectors calculated in the previous step.</li><li class="st300_list_item">Sample a tangent space normal vector <span class="st300_term variable">P</span> from the current normal map.</li><li class="st300_list_item">Transform the vector <span class="st300_term variable">P</span> with the matrix <span class="st300_term variable">M</span> by calculating <span class="st300_term expression">M * P</span>, resulting in an object space normal vector <span class="st300_term variable">Q</span>.</li><li class="st300_list_item">Transform the vector <span class="st300_term variable">Q</span> to eye space, in the same manner that an ordinary per-vertex normal vector would be (using the <a class="st300_link" href="p2s3.xhtml#di.coords.eye.normal-matrix">3x3 normal matrix</a> ).</li></ol></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss5c3" href="#st300_p2s23ss5c3" title="Paragraph 2.23.5.3">3</a></div><div class="st300_paragraph">Effectively, a "replacement" normal vector is sampled from the map, and transformed to object space using the existing <span class="st300_term expression">(T, B, N)</span> vectors. When the replacement normal vector is used when applying lighting, the effect is dramatic. Given a simple two-polygon square textured with the following albedo texture and normal map:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss5c4" href="#st300_p2s23ss5c4" title="Formal item 2.23.5.4: Example albedo and normal maps">2.23.5.4 Example albedo and normal maps</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Example albedo and normal maps" src="images/normalmap_metalpanels.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss5c5" href="#st300_p2s23ss5c5" title="Paragraph 2.23.5.5">5</a></div><div class="st300_paragraph">The square when textured and normal mapped, with three spherical lights:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss5c6" href="#st300_p2s23ss5c6" title="Formal item 2.23.5.6: Lit and normal mapped">2.23.5.6 Lit and normal mapped</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Lit and normal mapped" src="images/normalmap_applied.png"/></div></div><div class="st300_paragraph_container"><div class="st300_paragraph_number"><a id="st300_p2s23ss5c7" href="#st300_p2s23ss5c7" title="Paragraph 2.23.5.7">7</a></div><div class="st300_paragraph">The same square with the same lights but missing the normal map:</div></div><div class="st300_formal_item"><div class="st300_formal_item_title"><a id="st300_p2s23ss5c8" href="#st300_p2s23ss5c8" title="Formal item 2.23.5.8: Lit and not normal mapped">2.23.5.8 Lit and not normal mapped</a></div><div class="st300_formal_item_content"><img class="st300_image" alt="Lit and not normal mapped" src="images/normalmap_none.png"/></div></div></div><div class="st300_footnotes"><hr/><div class="st300_footnote_container"><div class="st300_footnote_id">[<a id="st300_f_18450_0" href="p2s23.xhtml#st300_fr_17906" title="Jump back to reference 0 of footnote di.normal-mapping.tangent-book">24</a>]</div><div class="st300_footnote_body">See section 7.8.3, "Calculating tangent vectors".</div></div></div></div><div class="st300_navbar st300_navbar_bottom"><hr class="st300_hr"/><table class="st300_navbar_table" summary="st300_Navigation bar"><tr><td class="st300_navbar_prev_file_cell"><a rel="previous" href="p2s22.xhtml#st300_p2s22" title="Go to previous page">Previous</a></td><td class="st300_navbar_up_file_cell"><a rel="up" href="p2.xhtml#st300_p2" title="Go to parent page">Up</a></td><td class="st300_navbar_next_file_cell"><a rel="next" href="p2s24.xhtml#st300_p2s24" title="Go to next page">Next</a></td></tr><tr><td class="st300_navbar_prev_title_cell">2.22. Forward rendering (Translucency)</td><td class="st300_navbar_up_title_cell">2. Design And Implementation</td><td class="st300_navbar_next_title_cell">2.24. Logarithmic Depth</td></tr></table></div></div></body></html>
