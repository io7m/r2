[section [title Normal Mapping] [id di.normal-mapping]]
[subsection [title Overview] [id di.normal-mapping.overview]]
[paragraph]
The [term [type package] r2] package supports the use of
[term [type term] tangent-space normal mapping] to allow for per-pixel control
over the surface normal of rendered triangles. This allows for meshes to appear
to have very complex surface details without requiring those details to actually
be rendered as triangles within the scene.

[subsection [title Tangent Space] [id di.normal-mapping.tangent-space]]
[paragraph]
Conceptually, there is a three-dimensional coordinate system based at each
vertex, formed by three orthonormal basis vectors: The vertex
[term [type term] normal], [term [type term] tangent] and
[term [type term] bitangent] vectors. The [term [type term] normal] vector is a
the vector perpendicular to the surface at that vertex. The
[term [type term] tangent] and [term [type term] bitangent] vectors are parallel
to the surface, and each vector is obviously perpendicular to the other two
vectors. This coordinate space is often referred to as
[term [type term] tangent space]. The [term [type term] normal] vector actually
forms the [term [type constant] Z] axis of the coordinate space, and this fact
is central to the process of normal mapping. The coordinate system at each
vertex may be left or right-handed depending on the arrangement of UV
coordinates at that vertex.

[formal-item [title Vertex coordinate system]]
[image [target "images/normal.png"] Vertex coordinate system]

[subsection [title Tangent/Bitangent Generation]
[id di.normal-mapping.tangent-bitangent-generation]]
[paragraph]
[term [type term] Tangent] and [term [type term] bitangent] vectors can be
generated by the modelling programs that artists use to create polygon meshes,
but, additionally, the
(link-ext (target "apidocs/com/io7m/r2/meshes/R2MeshTangents.html")
R2MeshTangents) class can take an arbitrary mesh with only normal vectors and UV
coordinates and produce tangent and bitangent vectors. The full description of
the algorithm used is given in
(link-ext (target "http://www.mathfor3dgameprogramming.com/")
Mathematics for 3D Game Programming and Computer Graphics, Third Edition)
[footnote-ref di.normal-mapping.tangent-book], and also in an
(link-ext (target "http://www.terathon.com/code/tangent.html") article) by the
same author. The actual aim of tangent/bitangent generation is to produce a pair
of orthogonal vectors that are oriented to the [term [type variable] x] and
[term [type variable] y] axes of an arbitrary texture. In order to do achieve
this, the generated vectors are oriented according to the UV coordinates in the
mesh.

[paragraph]
In the [term [type package] r2] package, the bitangent
vector is not actually stored in the mesh data, and the
tangent vector for any given vertex is instead stored as a
four-component vector. The reasons for this are as follows: Because the normal,
tangent, and bitangent vectors are known to be orthonormal, it should be
possible to reconstruct any one of the three vectors given the other two at
run-time. This would eliminate the need to store one of the vectors and would
reduce the size of mesh data "(including" the on-disk size, and the size of mesh
data allocated on the "GPU)" by a significant amount. Given any two orthogonal
vectors [term [type constant] V0] and [term [type constant] V1] , a vector
orthogonal to both can be calculated by taking the
[term [type term] cross product] of both, denoted
[term [type expression] "(cross V0 V1)"]. The problem here is that if
[term [type constant] V0] is assumed to be the original normal vector
[term [type constant] N], and [term [type constant] V1] is assumed to be the
original tangent vector [term [type constant] T], there is no guarantee that
[term [type expression] "(cross N T)"] will produce a vector equal to the
original bitangent vector [term [type constant] B]: There are two possible
choices of value for [term [type constant] B] that differ only in the sign of
their coordinate values.

[paragraph]
As an example, a triangle that will produce [term [type constant] T] and
[term [type constant] B] vectors that form a right-handed coordinate system with
the normal vector [term [type constant] N] "(with" UV coordinates indicated at
each "vertex):"

[formal-item [title "Tangent generation (RHC)"]]
[image [target "images/tangent_gen_RHC.png"]
"Tangent generation (Resulting in a right-handed coordinate system)"]

[paragraph]
The same triangle will produce vectors that form a left-handed system when
generating vectors for another vertex "(note" that the result of
[term [type expression] "(Vector3f.cross N T) = (Vector3f.negation B)"] "):"

[formal-item [title "Tangent generation (LHC)"]]
[image [target "images/tangent_gen_LHC.png"]
"Tangent generation (Resulting in a left-handed coordinate system)"]

[paragraph]
However, if the original tangent vector [term [type constant] T] was augmented
with a piece of extra information that indicated whether or not the result of
[term [type expression] "(cross N T)"] needed to be inverted, then
reconstructing [term [type constant] B] would be trivial. Therefore, the fourth
component of the tangent vector [term [type constant] T] contains
[term [type constant] 1.0] if [term [type expression] "(cross N T) = B"], and
[term [type constant] -1.0] if [term [type expression] "(cross N T) = -B"]. The
bitangent vector can therefore be reconstructed by calculating
[term [type expression] "cross (N, T.xyz) * T.w"].

[paragraph]
With the three vectors [term [type expression] "(T, B, N)"], it's now possible
construct a [term [type expression] 3x3] matrix that can transform arbitrary
vectors in (link (target di.normal-mapping.tangent-space) tangent space) to
(link (target di.coords.object) object space):

[formal-item [title Tangent → Object matrix]]
[image [target "images/tangent_object_matrix.png"] Tangent → Object matrix]

[paragraph]
With this matrix, it's now obviously possible to take an arbitrary vector in
tangent space and transform it to object space. Then, with the current
[term [type term] normal matrix] "(object" → "eye)," transform the object space
vector all the way to (link (target di.coords.eye) eye space) in the
same manner as ordinary per-vertex object space normal vectors.

[footnote [id di.normal-mapping.tangent-book]]
See section 7.8.3, "\"Calculating" tangent "vectors\"."

[subsection [title Normal Maps] [id di.normal-mapping.map]]
[paragraph]
A [term [type term] normal map] is an ordinary RGB texture where each texel
represents a tangent space normal vector. The [term [type variable] x]
coordinate is stored in the red channel, the [term [type variable] y] coordinate
is stored in the green channel, and the [term [type variable] z] coordinate is
stored in the blue channel. The original coordinate values are assumed to fall
within the inclusive range [term [type expression] "[-1.0, 1.0]"], and these
values are mapped to the range [term [type expression] "[0.0, 1.0]"] before
being encoded to a specific pixel format.

[paragraph]
As an example, the vector [term [type constant] "(0.0, 0.0, 1.0)"] is first
mapped to [term [type constant] "(0.5, 0.5, 1.0)"] and then, assuming an image
format with 8-bits of precision per color channel, encoded to
[term [type constant] "(0x7f, 0x7f, 0xff)"]. This results in a pale blue color
that is characteristic of tangent space normal maps:

[formal-item [title "(0.0, 0.0, 1.0)"]]
[image [target "images/normalmap_zerozeroone.png"] "(0.0, 0.0, 1.0)"]

[paragraph]
Typically, tangent space normal maps are generated from a simple height maps:
Greyscale images where [term [type constant] 0.0] denotes the lowest possible
height, and [term [type constant] 1.0] indicates the highest possible height.
There are multiple algorithms that are capable of generating normal vectors from
height maps, but the majority of them work from the same basic principle: For a
given pixel with value [term [type variable] h] at location
[term [type expression] "(x, y)"] in an image, the neighbouring pixel values at
[term [type expression] "(x - 1, y)"],
[term [type expression] "(x - 1, y - 1)"],
[term [type expression] "(x + 1, y)"],
[term [type expression] "(x + 1, y + 1)"] are compared with
[term [type variable] h] in order to determine the [term [type term] slope]
between the height values. As an example, the
(link-ext (target "https://en.wikipedia.org/wiki/Prewitt_operator")
"Prewitt (3x3) operator") when used from the
(link-ext (target "https://code.google.com/p/gimp-normalmap/") gimp-normalmap)
plugin will produce the following map from a given greyscale height map:

[formal-item [title Prewitt 3x3 normal map]]
[image [target "images/normalmap_fromheight.png"] Prewitt 3x3 normal map]

[paragraph]
It is reasonably easy to infer the general directions of vectors from a visual
inspection of a tangent space normal map alone. In the above image, the flat
faces of the bricks are mostly pale blue. This is because the tangent space
normal for that surface is pointing straight towards the viewer - mostly towards
the positive [term [type variable] z] direction. The right edges of the bricks
in the image are tinted with a pinkish hue - this indicates that the normal
vectors at that pixel point mostly towards the positive [term [type variable] x]
direction.

[subsection [title Rendering With Normal Maps]
[id di.normal-mapping.rendering]]
[paragraph]
As stated, the purpose of a normal map is to give per-pixel control over the
surface normal for a given triangle during rendering. The process is as follows:

[formal-item [title Rendering process]]
[list-ordered
  [item Calculate the bitangent vector [term [type constant] B] from the
  [term [type constant] N] and [term [type constant] T] vectors. This step is
  performed on a per-vertex basis "(in" the [term [type term] vertex shader]
  ")."]
  [item Construct a [term [type constant] 3x3] tangent → object matrix
  [term [type variable] M] from the [term [type expression] "(T, B, N)"]
  vectors. This step is performed on a per-fragment basis "(in" the
  [term [type term] fragment shader] ")" using the interpolated vectors
  calculated in the previous step.]
  [item Sample a tangent space normal vector [term [type variable] P] from the
  current normal map.]
  [item Transform the vector [term [type variable] P] with the matrix
  [term [type variable] M] by calculating [term [type expression] M * P],
  resulting in an object space normal vector [term [type variable] Q] .]
  [item Transform the vector [term [type variable] Q] to eye space, in the same
  manner that an ordinary per-vertex normal vector would be "(using" the
  (link (target di.coords.eye.normal-matrix) 3x3 normal matrix) ")."]]

[paragraph]
Effectively, a "\"replacement\"" normal vector is sampled from the map, and
transformed to object space using the existing
[term [type expression] "(T, B, N)"] vectors. When the replacement normal vector
is used when applying lighting, the effect is dramatic. Given a simple
two-polygon square textured with the following albedo texture and normal map:

[formal-item [title Example albedo and normal maps]]
[image [target "images/normalmap_metalpanels.png"]
Example albedo and normal maps]

[paragraph]
The square when textured and normal mapped, with three spherical lights:

[formal-item [title Lit and normal mapped]]
[image [target "images/normalmap_applied.png"] Lit and normal mapped]

[paragraph]
The same square with the same lights but missing the normal map:

[formal-item [title Lit and not normal mapped]]
[image [target "images/normalmap_none.png"] Lit and not normal mapped]
